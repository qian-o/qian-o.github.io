<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Textured Quad | Zenith.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Textured Quad | Zenith.NET ">
      
      
      <link rel="icon" href="../../images/Zenith.NET.png">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/qian-o/Zenith.NET/blob/master/documents/tutorials/getting-started/textured-quad.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/Zenith.NET-Logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="textured-quad">Textured Quad</h1>

<p>In this tutorial, you'll learn how to render a textured quad using Zenith.NET. We'll load an image, create a texture and sampler, and bind them to the shader using resource layouts.</p>
<h2 id="overview">Overview</h2>
<p>We'll create a <code>TexturedQuadRenderer</code> class that:</p>
<ul>
<li>Uses an index buffer to draw a quad with 4 vertices</li>
<li>Loads an image and uploads it to a GPU texture</li>
<li>Creates a sampler for texture filtering</li>
<li>Binds texture and sampler using <code>ResourceLayout</code> and <code>ResourceTable</code></li>
</ul>
<h2 id="project-setup">Project Setup</h2>
<h3 id="required-package">Required Package</h3>
<p>Add the ImageSharp extension for loading images:</p>
<pre><code class="lang-bash">dotnet add package Zenith.NET.Extensions.ImageSharp
</code></pre>
<p>Then add the global using to <code>Usings.cs</code>:</p>
<pre><code class="lang-csharp">global using Zenith.NET.Extensions.ImageSharp;
</code></pre>
<h3 id="assets-configuration">Assets Configuration</h3>
<p>Update your <code>.csproj</code> to copy assets to the output directory:</p>
<pre><code class="lang-xml">&lt;ItemGroup&gt;
  &lt;None Update=&quot;Assets\**\*&quot;&gt;
    &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
  &lt;/None&gt;
&lt;/ItemGroup&gt;
</code></pre>
<h3 id="sample-image">Sample Image</h3>
<p>This tutorial uses the following sample image. Right-click to save it to your project's <code>Assets</code> folder:</p>
<img src="../../images/shoko.png" alt="shoko" width="50%">
<p>Your project structure should now look like this:</p>
<pre><code>ZenithTutorials/
├── Assets/
│   └── shoko.png      # Save the image above as shoko.png
└── Renderers/
    └── TexturedQuadRenderer.cs
</code></pre>
<h2 id="the-renderer-class">The Renderer Class</h2>
<p>Create a new file <code>Renderers/TexturedQuadRenderer.cs</code>:</p>
<pre><code class="lang-csharp">namespace ZenithTutorials.Renderers;

internal unsafe class TexturedQuadRenderer : IRenderer
{
    private const string ShaderSource = &quot;&quot;&quot;
        struct VSInput
        {
            float3 Position : POSITION0;

            float2 TexCoord : TEXCOORD0;
        };

        struct PSInput
        {
            float4 Position : SV_POSITION;

            float2 TexCoord : TEXCOORD0;
        };

        Texture2D shaderTexture;
        SamplerState samplerState;

        PSInput VSMain(VSInput input)
        {
            PSInput output;
            output.Position = float4(input.Position, 1.0);
            output.TexCoord = input.TexCoord;

            return output;
        }

        float4 PSMain(PSInput input) : SV_TARGET
        {
            return shaderTexture.Sample(samplerState, input.TexCoord);
        }
        &quot;&quot;&quot;;

    private readonly Buffer vertexBuffer;
    private readonly Buffer indexBuffer;
    private readonly Texture texture;
    private readonly Sampler sampler;
    private readonly ResourceLayout resourceLayout;
    private readonly ResourceTable resourceTable;
    private readonly GraphicsPipeline pipeline;

    public TexturedQuadRenderer()
    {
        // UV origin (0,0) is top-left, (1,1) is bottom-right
        Vertex[] vertices =
        [
            new(new(-0.5f,  0.5f, 0.0f), new(0.0f, 0.0f)),
            new(new( 0.5f,  0.5f, 0.0f), new(1.0f, 0.0f)),
            new(new( 0.5f, -0.5f, 0.0f), new(1.0f, 1.0f)),
            new(new(-0.5f, -0.5f, 0.0f), new(0.0f, 1.0f))
        ];

        uint[] indices = [0, 1, 2, 0, 2, 3];

        vertexBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Vertex) * vertices.Length),
            StrideInBytes = (uint)sizeof(Vertex),
            Flags = BufferUsageFlags.Vertex | BufferUsageFlags.MapWrite
        });
        vertexBuffer.Upload(vertices, 0);

        indexBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(uint) * indices.Length),
            StrideInBytes = sizeof(uint),
            Flags = BufferUsageFlags.Index | BufferUsageFlags.MapWrite
        });
        indexBuffer.Upload(indices, 0);

        texture = App.Context.LoadTextureFromFile(Path.Combine(AppContext.BaseDirectory, &quot;Assets&quot;, &quot;shoko.png&quot;), generateMipMaps: true);

        sampler = App.Context.CreateSampler(new()
        {
            U = AddressMode.Clamp,
            V = AddressMode.Clamp,
            W = AddressMode.Clamp,
            Filter = Filter.MinLinearMagLinearMipLinear,
            MaxLod = uint.MaxValue
        });

        resourceLayout = App.Context.CreateResourceLayout(new()
        {
            Bindings = BindingHelper.Bindings
            (
                new() { Type = ResourceType.Texture, Count = 1, StageFlags = ShaderStageFlags.Pixel },
                new() { Type = ResourceType.Sampler, Count = 1, StageFlags = ShaderStageFlags.Pixel }
            )
        });

        resourceTable = App.Context.CreateResourceTable(new()
        {
            Layout = resourceLayout,
            Resources = [texture, sampler]
        });

        InputLayout inputLayout = new();
        inputLayout.Add(new() { Format = ElementFormat.Float3, Semantic = ElementSemantic.Position });
        inputLayout.Add(new() { Format = ElementFormat.Float2, Semantic = ElementSemantic.TexCoord });

        using Shader vertexShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;VSMain&quot;, ShaderStageFlags.Vertex);
        using Shader pixelShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;PSMain&quot;, ShaderStageFlags.Pixel);

        pipeline = App.Context.CreateGraphicsPipeline(new()
        {
            RenderStates = new()
            {
                RasterizerState = RasterizerStates.CullNone,
                DepthStencilState = DepthStencilStates.Default,
                BlendState = BlendStates.Opaque
            },
            Vertex = vertexShader,
            Pixel = pixelShader,
            ResourceLayout = resourceLayout,
            InputLayouts = [inputLayout],
            PrimitiveTopology = PrimitiveTopology.TriangleList,
            Output = App.SwapChain.FrameBuffer.Output
        });
    }

    public void Update(double deltaTime)
    {
    }

    public void Render()
    {
        CommandBuffer commandBuffer = App.Context.Graphics.CommandBuffer();

        commandBuffer.BeginRenderPass(App.SwapChain.FrameBuffer, new()
        {
            ColorValues = [new(0.1f, 0.1f, 0.1f, 1.0f)],
            Depth = 1.0f,
            Stencil = 0,
            Flags = ClearFlags.All
        }, resourceTable);

        commandBuffer.SetPipeline(pipeline);
        commandBuffer.SetResourceTable(resourceTable);
        commandBuffer.SetVertexBuffer(vertexBuffer, 0, 0);
        commandBuffer.SetIndexBuffer(indexBuffer, 0, IndexFormat.UInt32);
        commandBuffer.DrawIndexed(6, 1, 0, 0, 0);

        commandBuffer.EndRenderPass();

        commandBuffer.Submit(waitForCompletion: true);
    }

    public void Resize(uint width, uint height)
    {
    }

    public void Dispose()
    {
        pipeline.Dispose();
        resourceTable.Dispose();
        resourceLayout.Dispose();
        sampler.Dispose();
        texture.Dispose();
        indexBuffer.Dispose();
        vertexBuffer.Dispose();
    }
}

/// &lt;summary&gt;
/// Vertex structure with position and texture coordinates.
/// &lt;/summary&gt;
[StructLayout(LayoutKind.Sequential)]
file struct Vertex(Vector3 position, Vector2 texCoord)
{
    public Vector3 Position = position;

    public Vector2 TexCoord = texCoord;
}
</code></pre>
<h2 id="running-the-tutorial">Running the Tutorial</h2>
<p>Update your <code>Program.cs</code> to run the <code>TexturedQuadRenderer</code>:</p>
<pre><code class="lang-csharp">using ZenithTutorials;
using ZenithTutorials.Renderers;

App.Run&lt;TexturedQuadRenderer&gt;();

App.Cleanup();
</code></pre>
<p>Run the application:</p>
<pre><code class="lang-bash">dotnet run
</code></pre>
<h2 id="result">Result</h2>
<p><img src="../../images/textured-quad.png" alt="textured-quad"></p>
<h2 id="code-breakdown">Code Breakdown</h2>
<h3 id="vertex-structure">Vertex Structure</h3>
<pre><code class="lang-csharp">[StructLayout(LayoutKind.Sequential)]
file struct Vertex(Vector3 position, Vector2 texCoord)
{
    public Vector3 Position = position;

    public Vector2 TexCoord = texCoord;
}
</code></pre>
<p>Unlike the triangle tutorial, we now use <code>Vector2 TexCoord</code> instead of color. Texture coordinates (UVs) range from <code>(0,0)</code> at the top-left to <code>(1,1)</code> at the bottom-right.</p>
<h3 id="index-buffer">Index Buffer</h3>
<pre><code class="lang-csharp">uint[] indices = [0, 1, 2, 0, 2, 3];

indexBuffer = App.Context.CreateBuffer(new()
{
    SizeInBytes = (uint)(sizeof(uint) * indices.Length),
    StrideInBytes = sizeof(uint),
    Flags = BufferUsageFlags.Index | BufferUsageFlags.MapWrite
});
</code></pre>
<p>A quad requires 6 indices (2 triangles × 3 vertices). Using an index buffer reduces vertex data from 6 to 4 vertices by reusing shared vertices.</p>
<h3 id="loading-textures">Loading Textures</h3>
<pre><code class="lang-csharp">texture = App.Context.LoadTextureFromFile(Path.Combine(AppContext.BaseDirectory, &quot;Assets&quot;, &quot;shoko.png&quot;), generateMipMaps: true);
</code></pre>
<p>The <code>Zenith.NET.Extensions.ImageSharp</code> extension provides convenient methods to load images. Setting <code>generateMipMaps: true</code> creates smaller versions of the texture for better quality at different distances.</p>
<h3 id="sampler">Sampler</h3>
<pre><code class="lang-csharp">sampler = App.Context.CreateSampler(new()
{
    U = AddressMode.Clamp,
    V = AddressMode.Clamp,
    W = AddressMode.Clamp,
    Filter = Filter.MinLinearMagLinearMipLinear,
    MaxLod = uint.MaxValue
});
</code></pre>
<p>Samplers control how textures are read:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>U/V/W</code></td>
<td>How to handle coordinates outside 0-1 range</td>
</tr>
<tr>
<td><code>Filter</code></td>
<td>Interpolation method (linear = smooth, point = pixelated)</td>
</tr>
<tr>
<td><code>MaxLod</code></td>
<td>Maximum mipmap level to use</td>
</tr>
</tbody>
</table>
<h3 id="resource-binding">Resource Binding</h3>
<pre><code class="lang-csharp">// 1. Define the layout using BindingHelper for cross-platform compatibility
resourceLayout = App.Context.CreateResourceLayout(new()
{
    Bindings = BindingHelper.Bindings
    (
        new() { Type = ResourceType.Texture, Count = 1, StageFlags = ShaderStageFlags.Pixel },
        new() { Type = ResourceType.Sampler, Count = 1, StageFlags = ShaderStageFlags.Pixel }
    )
});

// 2. Create the table (bind actual resources)
resourceTable = App.Context.CreateResourceTable(new()
{
    Layout = resourceLayout,
    Resources = [texture, sampler]
});

// 3. Bind during rendering
commandBuffer.SetResourceTable(resourceTable);
</code></pre>
<p>This three-step process connects your GPU resources to shader variables:</p>
<ol>
<li><strong>ResourceLayout</strong> - Describes the structure (types and binding slots)</li>
<li><strong>ResourceTable</strong> - Binds actual resources to the layout</li>
<li><strong>SetResourceTable</strong> - Activates the binding during rendering</li>
</ol>
<p>The <code>BindingHelper.Bindings()</code> method (defined in <a href="prerequisites.html">Prerequisites</a>) automatically assigns the correct <code>Index</code> values based on the current backend, so you don't need to specify them manually.</p>
<h3 id="resource-preprocessing">Resource Preprocessing</h3>
<p>When beginning a render pass, you can pass resource tables to the <code>preprocessResourceTables</code> parameter:</p>
<pre><code class="lang-csharp">commandBuffer.BeginRenderPass(App.SwapChain.FrameBuffer, new()
{
    ColorValues = [new(0.1f, 0.1f, 0.1f, 1.0f)],
    Depth = 1.0f,
    Stencil = 0,
    Flags = ClearFlags.All
}, resourceTable);
</code></pre>
<p>This allows Zenith.NET to optimize the resources in the table for shader access before the render pass begins, eliminating the need for manual resource management.</p>
<h3 id="shader-texture-sampling">Shader Texture Sampling</h3>
<pre><code class="lang-slang">Texture2D shaderTexture;
SamplerState samplerState;

float4 PSMain(PSInput input) : SV_TARGET
{
    return shaderTexture.Sample(samplerState, input.TexCoord);
}
</code></pre>
<p>In Slang, resources are declared as global variables after the struct definitions, without explicit <code>register</code> bindings. The binding order is determined by declaration order and matches the order in <code>ResourceLayout.Bindings</code>. The pixel shader samples the texture at the interpolated UV coordinates.</p>
<h2 id="next-steps">Next Steps</h2>
<p>Now that you understand texturing and resource binding, the next tutorial covers 3D rendering:</p>
<ul>
<li><a href="spinning-cube.html">Spinning Cube</a> - Render a 3D cube with index buffers and MVP transformation matrices</li>
</ul>
<h2 id="source-code">Source Code</h2>
<div class="TIP">
<h5>Tip</h5>
<p>View the complete source code on GitHub: <a href="https://github.com/qian-o/ZenithTutorials/blob/master/ZenithTutorials/Renderers/TexturedQuadRenderer.cs">TexturedQuadRenderer.cs</a></p>
</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/qian-o/Zenith.NET/blob/master/documents/tutorials/getting-started/textured-quad.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
