<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Ray Tracing | Zenith.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Ray Tracing | Zenith.NET ">
      
      
      <link rel="icon" href="../../images/Zenith.NET.png">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/qian-o/Zenith.NET/blob/master/documents/tutorials/advanced/ray-tracing.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/Zenith.NET-Logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="ray-tracing">Ray Tracing</h1>

<p>In this tutorial, you'll learn how to use hardware-accelerated ray tracing with Zenith.NET. We'll render a scene with a checkered floor and a sphere, demonstrating acceleration structure construction and compute-shader-based ray tracing with <code>RayQuery</code>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>This tutorial requires a GPU with ray tracing support. Check <code>Context.Capabilities.RayTracingSupported</code> before using ray tracing features.</p>
</div>
<h2 id="overview">Overview</h2>
<p>We'll create a <code>RayTracingRenderer</code> class that:</p>
<ul>
<li>Creates floor geometry using triangle buffers</li>
<li>Creates a sphere using procedural AABBs</li>
<li>Builds separate BLAS for floor and sphere, combined in a TLAS</li>
<li>Uses a compute shader with <code>RayQuery</code> for ray tracing</li>
<li>Implements shadow rays for hard shadows</li>
<li>Copies the result to the swap chain for display</li>
</ul>
<h2 id="key-concepts">Key Concepts</h2>
<h3 id="ray-tracing-with-rayquery">Ray Tracing with RayQuery</h3>
<p>Zenith.NET uses <code>RayQuery</code> for ray tracing. This approach binds the acceleration structure as a regular resource and performs all ray tracing logic within a single shader:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Shader Stage</strong></td>
<td>Any shader (typically compute)</td>
</tr>
<tr>
<td><strong>Setup</strong></td>
<td>Bind acceleration structure to any pipeline</td>
</tr>
<tr>
<td><strong>Hit/Miss Logic</strong></td>
<td>All logic in one shader using <code>RayQuery</code> API</td>
</tr>
<tr>
<td><strong>Best For</strong></td>
<td>Shadows, AO, GI, reflections — any ray tracing workload</td>
</tr>
</tbody>
</table>
<h3 id="acceleration-structures">Acceleration Structures</h3>
<p>Ray tracing uses a two-level acceleration structure hierarchy:</p>
<ul>
<li><strong>BLAS (Bottom-Level Acceleration Structure)</strong>: Contains the actual geometry data. Each BLAS can store either triangle meshes or axis-aligned bounding boxes (AABBs) for procedural geometry.</li>
<li><strong>TLAS (Top-Level Acceleration Structure)</strong>: Contains instances that reference one or more BLAS with transform matrices. Multiple instances can share the same BLAS with different transforms.</li>
</ul>
<pre><code>TLAS (scene)
├── Instance 0 → BLAS 0 (floor, triangles)
├── Instance 1 → BLAS 1 (sphere, AABBs)
├── Instance 2 → BLAS 0 (same geometry, different transform)
└── ...
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Acceleration structure transforms only support rotation and scale. Translation is <strong>not supported</strong> - use the geometry's world-space coordinates directly.</p>
</div>
<h2 id="the-renderer-class">The Renderer Class</h2>
<p>Create a new file <code>Renderers/RayTracingRenderer.cs</code>:</p>
<pre><code class="lang-csharp">namespace ZenithTutorials.Renderers;

internal unsafe class RayTracingRenderer : IRenderer
{
    private const uint ThreadGroupSize = 16;

    private const string ShaderSource = &quot;&quot;&quot;
        struct Sphere
        {
            float3 Center;

            float Radius;

            float3 Color;

            float Padding;
        };

        RaytracingAccelerationStructure scene;
        StructuredBuffer&lt;Sphere&gt; spheres;
        RWTexture2D&lt;float4&gt; outputTexture;

        static const float3 LightDir = normalize(float3(1.0, 1.0, -0.5));
        static const float3 LightColor = float3(1.0, 0.98, 0.95);
        static const float3 AmbientColor = float3(0.1, 0.1, 0.15);

        float IntersectSphere(float3 origin, float3 direction, Sphere sphere)
        {
            float3 oc = origin - sphere.Center;

            float a = dot(direction, direction);
            float b = dot(oc, direction);
            float c = dot(oc, oc) - sphere.Radius * sphere.Radius;
            float discriminant = b * b - a * c;

            if (discriminant &gt; 0.0)
            {
                float sqrtD = sqrt(discriminant);
                float t1 = (-b - sqrtD) / a;

                if (t1 &gt; 0.0)
                {
                    return t1;
                }

                float t2 = (-b + sqrtD) / a;

                if (t2 &gt; 0.0)
                {
                    return t2;
                }
            }

            return -1.0;
        }

        bool TraceShadowRay(float3 origin, float3 direction)
        {
            RayDesc shadowRay;
            shadowRay.Origin = origin;
            shadowRay.Direction = direction;
            shadowRay.TMin = 0.001;
            shadowRay.TMax = 1000.0;

            RayQuery&lt;RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH&gt; shadowQuery;
            shadowQuery.TraceRayInline(scene, RAY_FLAG_NONE, 0xFF, shadowRay);

            while (shadowQuery.Proceed())
            {
                if (shadowQuery.CandidateType() == CANDIDATE_PROCEDURAL_PRIMITIVE)
                {
                    uint sphereIndex = shadowQuery.CandidatePrimitiveIndex();
                    Sphere sphere = spheres[sphereIndex];

                    float3 ro = shadowQuery.CandidateObjectRayOrigin();
                    float3 rd = shadowQuery.CandidateObjectRayDirection();

                    float t = IntersectSphere(ro, rd, sphere);

                    if (t &gt;= shadowQuery.RayTMin() &amp;&amp; t &lt;= shadowQuery.CommittedRayT())
                    {
                        shadowQuery.CommitProceduralPrimitiveHit(t);
                    }
                }
            }

            return shadowQuery.CommittedStatus() != COMMITTED_NOTHING;
        }

        [numthreads(16, 16, 1)]
        void CSMain(uint3 dispatchThreadID : SV_DispatchThreadID)
        {
            uint2 pixelCoord = dispatchThreadID.xy;

            uint width, height;
            outputTexture.GetDimensions(width, height);

            if (pixelCoord.x &gt;= width || pixelCoord.y &gt;= height)
            {
                return;
            }

            float2 uv = (float2(pixelCoord) + 0.5) / float2(width, height);
            float2 ndc = uv * 2.0 - 1.0;
            ndc.y = -ndc.y;

            float aspectRatio = float(width) / float(height);
            float fov = tan(radians(45.0) * 0.5);

            float3 cameraPos = float3(0.0, 4.0, -12.0);
            float3 cameraTarget = float3(0.0, 0.0, 0.0);
            float3 cameraUp = float3(0.0, 1.0, 0.0);

            float3 forward = normalize(cameraTarget - cameraPos);
            float3 right = normalize(cross(forward, cameraUp));
            float3 up = cross(right, forward);

            float3 rayDir = normalize(forward + ndc.x * aspectRatio * fov * right + ndc.y * fov * up);

            RayDesc ray;
            ray.Origin = cameraPos;
            ray.Direction = rayDir;
            ray.TMin = 0.001;
            ray.TMax = 1000.0;

            float3 sphereHitNormal = float3(0.0);
            float3 sphereHitColor = float3(0.0);

            RayQuery&lt;RAY_FLAG_NONE&gt; query;
            query.TraceRayInline(scene, RAY_FLAG_NONE, 0xFF, ray);

            while (query.Proceed())
            {
                if (query.CandidateType() == CANDIDATE_PROCEDURAL_PRIMITIVE)
                {
                    uint sphereIndex = query.CandidatePrimitiveIndex();
                    Sphere sphere = spheres[sphereIndex];

                    float3 ro = query.CandidateObjectRayOrigin();
                    float3 rd = query.CandidateObjectRayDirection();

                    float t = IntersectSphere(ro, rd, sphere);

                    if (t &gt;= query.RayTMin() &amp;&amp; t &lt;= query.CommittedRayT())
                    {
                        float3 hitPoint = ro + rd * t;

                        sphereHitNormal = normalize(hitPoint - sphere.Center);
                        sphereHitColor = sphere.Color;

                        query.CommitProceduralPrimitiveHit(t);
                    }
                }
            }

            float3 color;

            if (query.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
            {
                float3 hitPoint = ray.Origin + ray.Direction * query.CommittedRayT();

                float scale = 1.0;
                int checkX = int(floor(hitPoint.x * scale));
                int checkZ = int(floor(hitPoint.z * scale));
                bool isWhite = ((checkX + checkZ) &amp; 1) == 0;
                float3 baseColor = isWhite ? float3(0.9, 0.9, 0.9) : float3(0.2, 0.2, 0.2);

                float3 normal = float3(0.0, 1.0, 0.0);
                float NdotL = max(dot(normal, LightDir), 0.0);

                float3 shadowOrigin = hitPoint + normal * 0.001;
                bool inShadow = TraceShadowRay(shadowOrigin, LightDir);

                float shadow = inShadow ? 0.3 : 1.0;
                float3 diffuse = baseColor * LightColor * NdotL * shadow;
                float3 ambient = baseColor * AmbientColor;

                color = ambient + diffuse;
            }
            else if (query.CommittedStatus() == COMMITTED_PROCEDURAL_PRIMITIVE_HIT)
            {
                float3 hitPoint = ray.Origin + ray.Direction * query.CommittedRayT();

                float NdotL = max(dot(sphereHitNormal, LightDir), 0.0);

                float3 shadowOrigin = hitPoint + sphereHitNormal * 0.001;
                bool inShadow = TraceShadowRay(shadowOrigin, LightDir);

                float shadow = inShadow ? 0.3 : 1.0;
                float3 diffuse = sphereHitColor * LightColor * NdotL * shadow;
                float3 ambient = sphereHitColor * AmbientColor;

                color = ambient + diffuse;
            }
            else
            {
                float t = 0.5 * (rayDir.y + 1.0);

                color = lerp(float3(1.0, 1.0, 1.0), float3(0.5, 0.7, 1.0), t);
            }

            color = pow(color, 1.0 / 2.2);

            outputTexture[pixelCoord] = float4(color, 1.0);
        }
        &quot;&quot;&quot;;

    private readonly Buffer floorVertexBuffer;
    private readonly Buffer floorIndexBuffer;
    private readonly Buffer sphereBuffer;
    private readonly Buffer aabbBuffer;
    private readonly BottomLevelAccelerationStructure floorBlas;
    private readonly BottomLevelAccelerationStructure sphereBlas;
    private readonly TopLevelAccelerationStructure tlas;
    private readonly ResourceLayout resourceLayout;
    private readonly ComputePipeline pipeline;
    private Texture? outputTexture;
    private ResourceTable? resourceTable;

    public RayTracingRenderer()
    {
        if (!App.Context.Capabilities.RayTracingSupported)
        {
            throw new NotSupportedException(&quot;Ray tracing is not supported on this device.&quot;);
        }

        Vector3[] floorVertices =
        [
            new(-5.0f, 0.0f, -5.0f),
            new( 5.0f, 0.0f, -5.0f),
            new( 5.0f, 0.0f,  5.0f),
            new(-5.0f, 0.0f,  5.0f)
        ];
        uint[] floorIndices = [0, 1, 2, 0, 2, 3];

        floorVertexBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Vector3) * floorVertices.Length),
            StrideInBytes = (uint)sizeof(Vector3),
            Flags = BufferUsageFlags.Vertex | BufferUsageFlags.AccelerationStructure
        });
        floorVertexBuffer.Upload(floorVertices, 0);

        floorIndexBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(uint) * floorIndices.Length),
            StrideInBytes = sizeof(uint),
            Flags = BufferUsageFlags.Index | BufferUsageFlags.AccelerationStructure
        });
        floorIndexBuffer.Upload(floorIndices, 0);

        Sphere[] sphereData =
        [
            new() { Center = new(-1.5f, 1.0f, 0.0f), Radius = 1.0f, Color = new(0.8f, 0.2f, 0.2f) },
            new() { Center = new( 1.5f, 1.0f, 0.0f), Radius = 1.0f, Color = new(0.2f, 0.4f, 0.8f) }
        ];

        sphereBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Sphere) * sphereData.Length),
            StrideInBytes = (uint)sizeof(Sphere),
            Flags = BufferUsageFlags.ShaderResource
        });
        sphereBuffer.Upload(sphereData, 0);

        Vector3[] aabbData = new Vector3[sphereData.Length * 2];
        for (int i = 0; i &lt; sphereData.Length; i++)
        {
            aabbData[i * 2] = sphereData[i].Center - new Vector3(sphereData[i].Radius);
            aabbData[(i * 2) + 1] = sphereData[i].Center + new Vector3(sphereData[i].Radius);
        }

        aabbBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Vector3) * aabbData.Length),
            StrideInBytes = (uint)(sizeof(Vector3) * 2),
            Flags = BufferUsageFlags.ShaderResource | BufferUsageFlags.AccelerationStructure
        });
        aabbBuffer.Upload(aabbData, 0);

        CommandBuffer buildCmd = App.Context.Graphics.CommandBuffer();

        floorBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
        {
            Geometries =
            [
                new()
                {
                    Type = RayTracingGeometryType.Triangles,
                    Triangles = new()
                    {
                        VertexBuffer = floorVertexBuffer,
                        VertexFormat = PixelFormat.R32G32B32Float,
                        VertexCount = (uint)floorVertices.Length,
                        VertexStrideInBytes = (uint)sizeof(Vector3),
                        IndexBuffer = floorIndexBuffer,
                        IndexFormat = IndexFormat.UInt32,
                        IndexCount = (uint)floorIndices.Length,
                        Transform = Matrix4x4.Identity
                    },
                    Flags = RayTracingGeometryFlags.Opaque
                }
            ],
            Flags = AccelerationStructureBuildFlags.PreferFastTrace
        });

        sphereBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
        {
            Geometries =
            [
                new()
                {
                    Type = RayTracingGeometryType.AABBs,
                    AABBs = new()
                    {
                        Buffer = aabbBuffer,
                        Count = (uint)sphereData.Length,
                        StrideInBytes = (uint)(sizeof(Vector3) * 2)
                    },
                    Flags = RayTracingGeometryFlags.Opaque
                }
            ],
            Flags = AccelerationStructureBuildFlags.PreferFastTrace
        });

        tlas = buildCmd.BuildAccelerationStructure(new TopLevelAccelerationStructureDesc
        {
            Instances =
            [
                new()
                {
                    AccelerationStructure = floorBlas,
                    InstanceID = 0,
                    InstanceMask = 0xFF,
                    Transform = Matrix4x4.Identity,
                    Flags = RayTracingInstanceFlags.None
                },
                new()
                {
                    AccelerationStructure = sphereBlas,
                    InstanceID = 1,
                    InstanceMask = 0xFF,
                    Transform = Matrix4x4.Identity,
                    Flags = RayTracingInstanceFlags.None
                }
            ],
            Flags = AccelerationStructureBuildFlags.PreferFastTrace
        });

        buildCmd.Submit(waitForCompletion: true);

        resourceLayout = App.Context.CreateResourceLayout(new()
        {
            Bindings = BindingHelper.Bindings
            (
                new() { Type = ResourceType.AccelerationStructure, Count = 1, StageFlags = ShaderStageFlags.Compute },
                new() { Type = ResourceType.StructuredBuffer, Count = 1, StageFlags = ShaderStageFlags.Compute },
                new() { Type = ResourceType.TextureReadWrite, Count = 1, StageFlags = ShaderStageFlags.Compute }
            )
        });

        using Shader computeShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;CSMain&quot;, ShaderStageFlags.Compute);

        pipeline = App.Context.CreateComputePipeline(new()
        {
            Compute = computeShader,
            ResourceLayout = resourceLayout,
            ThreadGroupSizeX = ThreadGroupSize,
            ThreadGroupSizeY = ThreadGroupSize,
            ThreadGroupSizeZ = 1
        });
    }

    public void Update(double deltaTime)
    {
    }

    public void Render()
    {
        outputTexture ??= App.Context.CreateTexture(new()
        {
            Type = TextureType.Texture2D,
            Format = PixelFormat.B8G8R8A8UNorm,
            Width = App.Width,
            Height = App.Height,
            Depth = 1,
            MipLevels = 1,
            ArrayLayers = 1,
            SampleCount = SampleCount.Count1,
            Flags = TextureUsageFlags.ShaderResource | TextureUsageFlags.UnorderedAccess
        });

        resourceTable ??= App.Context.CreateResourceTable(new()
        {
            Layout = resourceLayout,
            Resources = [tlas, sphereBuffer, outputTexture]
        });

        CommandBuffer commandBuffer = App.Context.Graphics.CommandBuffer();

        commandBuffer.SetPipeline(pipeline);
        commandBuffer.SetResourceTable(resourceTable);

        uint dispatchX = (App.Width + ThreadGroupSize - 1) / ThreadGroupSize;
        uint dispatchY = (App.Height + ThreadGroupSize - 1) / ThreadGroupSize;

        commandBuffer.Dispatch(dispatchX, dispatchY, 1);

        Texture colorTarget = App.SwapChain.FrameBuffer.Desc.ColorAttachments[0].Target;

        commandBuffer.CopyTexture(outputTexture,
                                  default,
                                  default,
                                  colorTarget,
                                  default,
                                  default,
                                  new() { Width = App.Width, Height = App.Height, Depth = 1 });

        commandBuffer.Submit(waitForCompletion: true);
    }

    public void Resize(uint width, uint height)
    {
        resourceTable?.Dispose();
        resourceTable = null;
        outputTexture?.Dispose();
        outputTexture = null;
    }

    public void Dispose()
    {
        resourceTable?.Dispose();
        outputTexture?.Dispose();

        pipeline.Dispose();
        resourceLayout.Dispose();
        tlas.Dispose();
        sphereBlas.Dispose();
        floorBlas.Dispose();
        aabbBuffer.Dispose();
        sphereBuffer.Dispose();
        floorIndexBuffer.Dispose();
        floorVertexBuffer.Dispose();
    }
}

/// &lt;summary&gt;
/// Sphere definition for procedural geometry.
/// &lt;/summary&gt;
[StructLayout(LayoutKind.Sequential)]
file struct Sphere
{
    public Vector3 Center;

    public float Radius;

    public Vector3 Color;

    public float Padding;
}
</code></pre>
<h2 id="running-the-tutorial">Running the Tutorial</h2>
<p>Update your <code>Program.cs</code> to run the <code>RayTracingRenderer</code>:</p>
<pre><code class="lang-csharp">using ZenithTutorials;
using ZenithTutorials.Renderers;

App.Run&lt;RayTracingRenderer&gt;();

App.Cleanup();
</code></pre>
<p>Run the application:</p>
<pre><code class="lang-bash">dotnet run
</code></pre>
<h2 id="result">Result</h2>
<p><img src="../../images/ray-tracing.png" alt="ray-tracing"></p>
<h2 id="code-breakdown">Code Breakdown</h2>
<h3 id="checking-ray-tracing-support">Checking Ray Tracing Support</h3>
<pre><code class="lang-csharp">if (!App.Context.Capabilities.RayTracingSupported)
{
    throw new NotSupportedException(&quot;Ray tracing is not supported on this device.&quot;);
}
</code></pre>
<p>Always check <code>Capabilities.RayTracingSupported</code> before using ray tracing features.</p>
<h3 id="acceleration-structure-setup">Acceleration Structure Setup</h3>
<p>Build a two-level acceleration structure hierarchy:</p>
<pre><code class="lang-csharp">// Floor BLAS (triangle geometry)
floorBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
{
    Geometries =
    [
        new()
        {
            Type = RayTracingGeometryType.Triangles,
            Triangles = new()
            {
                VertexBuffer = floorVertexBuffer,
                VertexFormat = PixelFormat.R32G32B32Float,
                VertexCount = (uint)floorVertices.Length,
                VertexStrideInBytes = (uint)sizeof(Vector3),
                IndexBuffer = floorIndexBuffer,
                IndexFormat = IndexFormat.UInt32,
                IndexCount = (uint)floorIndices.Length,
                Transform = Matrix4x4.Identity
            },
            Flags = RayTracingGeometryFlags.Opaque
        }
    ],
    Flags = AccelerationStructureBuildFlags.PreferFastTrace
});

// Sphere BLAS (procedural AABB geometry)
sphereBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
{
    Geometries =
    [
        new()
        {
            Type = RayTracingGeometryType.AABBs,
            AABBs = new()
            {
                Buffer = aabbBuffer,
                Count = (uint)sphereData.Length,
                StrideInBytes = (uint)(sizeof(Vector3) * 2)
            },
            Flags = RayTracingGeometryFlags.Opaque
        }
    ],
    Flags = AccelerationStructureBuildFlags.PreferFastTrace
});
</code></pre>
<p>Combine BLAS into a TLAS:</p>
<pre><code class="lang-csharp">tlas = buildCmd.BuildAccelerationStructure(new TopLevelAccelerationStructureDesc
{
    Instances =
    [
        new()
        {
            AccelerationStructure = floorBlas,
            InstanceID = 0,
            InstanceMask = 0xFF,
            Transform = Matrix4x4.Identity,
            ...
        },
        new()
        {
            AccelerationStructure = sphereBlas,
            InstanceID = 1,
            InstanceMask = 0xFF,
            Transform = Matrix4x4.Identity,
            ...
        }
    ],
    Flags = AccelerationStructureBuildFlags.PreferFastTrace
});
</code></pre>
<h3 id="ray-tracing-with-rayquery-1">Ray Tracing with RayQuery</h3>
<p>Ray tracing in Zenith.NET uses <code>RayQuery</code> within a compute shader. Procedural geometry requires a custom intersection function:</p>
<pre><code class="lang-slang">float IntersectSphere(float3 origin, float3 direction, Sphere sphere)
{
    float3 oc = origin - sphere.Center;

    float a = dot(direction, direction);
    float b = dot(oc, direction);
    float c = dot(oc, oc) - sphere.Radius * sphere.Radius;
    float discriminant = b * b - a * c;

    if (discriminant &gt; 0.0)
    {
        float sqrtD = sqrt(discriminant);
        float t1 = (-b - sqrtD) / a;

        if (t1 &gt; 0.0)
        {
            return t1;
        }

        float t2 = (-b + sqrtD) / a;

        if (t2 &gt; 0.0)
        {
            return t2;
        }
    }

    return -1.0;
}
</code></pre>
<p>The main ray query loop processes only procedural candidates, storing hit information for later use:</p>
<pre><code class="lang-slang">float3 sphereHitNormal = float3(0.0);
float3 sphereHitColor = float3(0.0);

RayQuery&lt;RAY_FLAG_NONE&gt; query;
query.TraceRayInline(scene, RAY_FLAG_NONE, 0xFF, ray);

while (query.Proceed())
{
    if (query.CandidateType() == CANDIDATE_PROCEDURAL_PRIMITIVE)
    {
        uint sphereIndex = query.CandidatePrimitiveIndex();
        Sphere sphere = spheres[sphereIndex];

        float t = IntersectSphere(ro, rd, sphere);

        if (t &gt;= query.RayTMin() &amp;&amp; t &lt;= query.CommittedRayT())
        {
            sphereHitNormal = normalize(hitPoint - sphere.Center);
            sphereHitColor = sphere.Color;

            query.CommitProceduralPrimitiveHit(t);
        }
    }
}

// Check result
if (query.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
{
    // Handle triangle hit
}
else if (query.CommittedStatus() == COMMITTED_PROCEDURAL_PRIMITIVE_HIT)
{
    // Handle procedural hit using stored normal and color
}
</code></pre>
<p>Key elements:</p>
<table>
<thead>
<tr>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RayQuery&lt;FLAGS&gt;</code></td>
<td>Declares a ray query with template ray flags</td>
</tr>
<tr>
<td><code>TraceRayInline</code></td>
<td>Initiates the ray traversal</td>
</tr>
<tr>
<td><code>Proceed()</code></td>
<td>Advances traversal; returns <code>true</code> while candidates remain</td>
</tr>
<tr>
<td><code>CandidateType()</code></td>
<td>Returns the type of the current candidate hit</td>
</tr>
<tr>
<td><code>CommitNonOpaqueTriangleHit()</code></td>
<td>Accepts a triangle hit</td>
</tr>
<tr>
<td><code>CommitProceduralPrimitiveHit(t)</code></td>
<td>Accepts a procedural hit at distance <code>t</code></td>
</tr>
<tr>
<td><code>CommittedStatus()</code></td>
<td>Returns the final hit result after traversal</td>
</tr>
</tbody>
</table>
<h3 id="shadow-rays-with-rayquery">Shadow Rays with RayQuery</h3>
<p>Shadow rays test visibility to a light source. Note that shadow rays must also handle procedural geometry intersections:</p>
<pre><code class="lang-slang">bool TraceShadowRay(float3 origin, float3 direction)
{
    RayDesc shadowRay;
    shadowRay.Origin = origin;
    shadowRay.Direction = direction;
    shadowRay.TMin = 0.001;
    shadowRay.TMax = 1000.0;

    RayQuery&lt;RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH&gt; shadowQuery;
    shadowQuery.TraceRayInline(scene, RAY_FLAG_NONE, 0xFF, shadowRay);

    while (shadowQuery.Proceed())
    {
        if (shadowQuery.CandidateType() == CANDIDATE_PROCEDURAL_PRIMITIVE)
        {
            uint sphereIndex = shadowQuery.CandidatePrimitiveIndex();
            Sphere sphere = spheres[sphereIndex];

            float t = IntersectSphere(ro, rd, sphere);

            if (t &gt;= shadowQuery.RayTMin() &amp;&amp; t &lt;= shadowQuery.CommittedRayT())
            {
                shadowQuery.CommitProceduralPrimitiveHit(t);
            }
        }
    }

    return shadowQuery.CommittedStatus() != COMMITTED_NOTHING;
}
</code></pre>
<p>Key optimization: <code>RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH</code> stops at the first hit since we only need to know if something blocks the light.</p>
<h3 id="compute-pipeline-for-ray-tracing">Compute Pipeline for Ray Tracing</h3>
<pre><code class="lang-csharp">resourceLayout = App.Context.CreateResourceLayout(new()
{
    Bindings = BindingHelper.Bindings
    (
        new() { Type = ResourceType.AccelerationStructure, Count = 1, StageFlags = ShaderStageFlags.Compute },
        new() { Type = ResourceType.StructuredBuffer, Count = 1, StageFlags = ShaderStageFlags.Compute },
        new() { Type = ResourceType.TextureReadWrite, Count = 1, StageFlags = ShaderStageFlags.Compute }
    )
});

pipeline = App.Context.CreateComputePipeline(new()
{
    Compute = computeShader,
    ResourceLayout = resourceLayout,
    ThreadGroupSizeX = ThreadGroupSize,
    ThreadGroupSizeY = ThreadGroupSize,
    ThreadGroupSizeZ = 1
});
</code></pre>
<p>Note that all resource bindings use <code>ShaderStageFlags.Compute</code> since ray tracing runs entirely within a compute shader.</p>
<h3 id="dispatching-and-display">Dispatching and Display</h3>
<pre><code class="lang-csharp">uint dispatchX = (App.Width + ThreadGroupSize - 1) / ThreadGroupSize;
uint dispatchY = (App.Height + ThreadGroupSize - 1) / ThreadGroupSize;

commandBuffer.SetPipeline(pipeline);
commandBuffer.SetResourceTable(resourceTable);
commandBuffer.Dispatch(dispatchX, dispatchY, 1);
</code></pre>
<p>The compute shader processes each pixel independently. The result is then copied to the swap chain's color target for display.</p>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li><a href="mesh-shading.html">Mesh Shading</a> - Process geometry in meshlets using the modern mesh shading pipeline</li>
</ul>
<h2 id="source-code">Source Code</h2>
<div class="TIP">
<h5>Tip</h5>
<p>View the complete source code on GitHub: <a href="https://github.com/qian-o/ZenithTutorials/blob/master/ZenithTutorials/Renderers/RayTracingRenderer.cs">RayTracingRenderer.cs</a></p>
</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/qian-o/Zenith.NET/blob/master/documents/tutorials/advanced/ray-tracing.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
