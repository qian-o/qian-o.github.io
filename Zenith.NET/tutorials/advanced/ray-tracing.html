<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Ray Tracing | Zenith.NET </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Ray Tracing | Zenith.NET ">
      
      
      <link rel="icon" href="../../images/Zenith.NET.png">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/qian-o/Zenith.NET/blob/master/documents/tutorials/advanced/ray-tracing.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../images/Zenith.NET-Logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="ray-tracing">Ray Tracing</h1>

<p>In this tutorial, you'll learn how to use hardware-accelerated ray tracing with Zenith.NET. We'll render a scene with a checkered floor and two spheres, demonstrating triangle geometry, procedural geometry (AABBs), and hard shadows.</p>
<div class="NOTE">
<h5>Note</h5>
<p>This tutorial requires a GPU with ray tracing support. Check <code>Context.Capabilities.RayTracingSupported</code> before using ray tracing features.</p>
</div>
<h2 id="overview">Overview</h2>
<p>We'll create a <code>RayTracingRenderer</code> class that:</p>
<ul>
<li>Creates a checkered floor using triangle geometry</li>
<li>Creates two spheres using procedural AABBs with a custom intersection shader</li>
<li>Builds separate BLAS for floor and spheres, combined in a TLAS</li>
<li>Implements shadow rays for hard shadows</li>
<li>Creates a ray tracing pipeline with multiple hit groups</li>
<li>Copies the result to the swap chain for display</li>
</ul>
<h2 id="key-concepts">Key Concepts</h2>
<h3 id="two-ways-to-use-ray-tracing">Two Ways to Use Ray Tracing</h3>
<p>There are two approaches to use hardware ray tracing:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Ray Tracing Pipeline</th>
<th>Inline Ray Tracing (RayQuery)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Shader Stages</strong></td>
<td>RayGen, Miss, ClosestHit, AnyHit, Intersection</td>
<td>Any shader (CS, PS, etc.)</td>
</tr>
<tr>
<td><strong>Setup Complexity</strong></td>
<td>Requires dedicated pipeline and hit groups</td>
<td>Bind acceleration structure only</td>
</tr>
<tr>
<td><strong>Hit/Miss Logic</strong></td>
<td>Separated into different shaders</td>
<td>All logic in one shader</td>
</tr>
<tr>
<td><strong>Best For</strong></td>
<td>Complex materials, multiple ray types</td>
<td>Simple queries, shadows, AO</td>
</tr>
</tbody>
</table>
<p>This tutorial covers the <strong>Ray Tracing Pipeline</strong> approach. For Inline Ray Tracing, simply bind the acceleration structure to your compute/graphics pipeline and use <code>RayQuery</code> in your shader.</p>
<h3 id="acceleration-structures">Acceleration Structures</h3>
<p>Ray tracing uses a two-level acceleration structure hierarchy:</p>
<ul>
<li><strong>BLAS (Bottom-Level Acceleration Structure)</strong>: Contains the actual geometry data. Each BLAS can store either triangle meshes or axis-aligned bounding boxes (AABBs) for procedural geometry.</li>
<li><strong>TLAS (Top-Level Acceleration Structure)</strong>: Contains instances that reference one or more BLAS with transform matrices. Multiple instances can share the same BLAS with different transforms.</li>
</ul>
<pre><code>TLAS (scene)
├── Instance 0 → BLAS 0 (floor, triangles)
├── Instance 1 → BLAS 1 (spheres, AABBs)
├── Instance 2 → BLAS 0 (same geometry, different transform)
└── ...
</code></pre>
<div class="IMPORTANT">
<h5>Important</h5>
<p>Acceleration structure transforms only support rotation and scale. Translation is <strong>not supported</strong> - use the geometry's world-space coordinates directly.</p>
</div>
<h3 id="ray-tracing-pipeline-stages">Ray Tracing Pipeline Stages</h3>
<table>
<thead>
<tr>
<th>Shader Stage</th>
<th>When Called</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Ray Generation</strong></td>
<td>Entry point - invoked for each pixel/thread</td>
</tr>
<tr>
<td><strong>Miss</strong></td>
<td>When the ray hits nothing</td>
</tr>
<tr>
<td><strong>Any Hit</strong></td>
<td>For each potential intersection - can accept/reject hit (alpha testing)</td>
</tr>
<tr>
<td><strong>Intersection</strong></td>
<td>For procedural geometry (AABBs) to compute ray-geometry intersection</td>
</tr>
<tr>
<td><strong>Closest Hit</strong></td>
<td>Once per ray, for the nearest accepted intersection</td>
</tr>
</tbody>
</table>
<h3 id="hit-groups">Hit Groups</h3>
<p>Hit Groups bundle shaders that work together for a specific geometry type:</p>
<table>
<thead>
<tr>
<th>Shader</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AnyHit</strong></td>
<td>Optional</td>
<td>Called for each potential hit (alpha testing, transparency)</td>
</tr>
<tr>
<td><strong>Intersection</strong></td>
<td>Optional</td>
<td>Custom intersection for procedural geometry. Required only for AABBs, triangles use built-in intersection.</td>
</tr>
<tr>
<td><strong>ClosestHit</strong></td>
<td>Optional</td>
<td>Called for the closest intersection point</td>
</tr>
</tbody>
</table>
<h2 id="the-renderer-class">The Renderer Class</h2>
<p>Create a new file <code>Renderers/RayTracingRenderer.cs</code>:</p>
<pre><code class="lang-csharp">namespace ZenithTutorials.Renderers;

internal unsafe class RayTracingRenderer : IRenderer
{
    // Ray tracing shader source
    private const string ShaderSource = &quot;&quot;&quot;
        struct Sphere
        {
            float3 Center;

            float Radius;

            float3 Color;

            float Padding;
        };

        struct Payload
        {
            float3 Color;

            float T;
        };

        struct ShadowPayload
        {
            bool InShadow;
        };

        struct SphereAttributes
        {
            float3 Normal;
        };

        // Resources
        RaytracingAccelerationStructure scene;
        RWTexture2D&lt;float4&gt; outputTexture;
        StructuredBuffer&lt;Sphere&gt; spheres;

        // Constants
        static const float3 LightDir = normalize(float3(1.0, 1.0, -0.5));
        static const float3 LightColor = float3(1.0, 0.98, 0.95);
        static const float3 AmbientColor = float3(0.1, 0.1, 0.15);

        [shader(&quot;raygeneration&quot;)]
        void RayGen()
        {
            uint2 pixelCoord = DispatchRaysIndex().xy;
            uint2 dimensions = DispatchRaysDimensions().xy;

            // Camera setup - perspective projection
            float2 uv = (float2(pixelCoord) + 0.5) / float2(dimensions);
            float2 ndc = uv * 2.0 - 1.0;
            ndc.y = -ndc.y;

            float aspectRatio = float(dimensions.x) / float(dimensions.y);
            float fov = tan(radians(45.0) * 0.5);  // 45 degree FOV

            float3 cameraPos = float3(0.0, 4.0, -12.0);
            float3 cameraTarget = float3(0.0, 0.0, 0.0);
            float3 cameraUp = float3(0.0, 1.0, 0.0);

            float3 forward = normalize(cameraTarget - cameraPos);
            float3 right = normalize(cross(forward, cameraUp));
            float3 up = cross(right, forward);

            float3 rayDir = normalize(forward + ndc.x * aspectRatio * fov * right + ndc.y * fov * up);

            RayDesc ray;
            ray.Origin = cameraPos;
            ray.Direction = rayDir;
            ray.TMin = 0.001;
            ray.TMax = 1000.0;

            Payload payload;
            payload.Color = float3(0.0, 0.0, 0.0);
            payload.T = -1.0;

            TraceRay(scene, RAY_FLAG_NONE, 0xFF, 0, 0, 0, ray, payload);

            // Gamma correction
            float3 color = pow(payload.Color, 1.0 / 2.2);

            outputTexture[pixelCoord] = float4(color, 1.0);
        }

        [shader(&quot;miss&quot;)]
        void Miss(inout Payload payload)
        {
            // Sky gradient background
            float3 rayDir = WorldRayDirection();
            float t = 0.5 * (rayDir.y + 1.0);

            payload.Color = lerp(float3(1.0, 1.0, 1.0), float3(0.5, 0.7, 1.0), t);
        }

        [shader(&quot;miss&quot;)]
        void ShadowMiss(inout ShadowPayload payload)
        {
            payload.InShadow = false;
        }

        bool TraceShadowRay(float3 origin, float3 direction)
        {
            RayDesc shadowRay;
            shadowRay.Origin = origin;
            shadowRay.Direction = direction;
            shadowRay.TMin = 0.001;
            shadowRay.TMax = 1000.0;

            ShadowPayload shadowPayload;
            shadowPayload.InShadow = true;

            TraceRay(scene,
                     RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
                     0xFF, 0, 0, 1, shadowRay, shadowPayload);

            return shadowPayload.InShadow;
        }

        [shader(&quot;closesthit&quot;)]
        void FloorClosestHit(inout Payload payload, BuiltInTriangleIntersectionAttributes attribs)
        {
            float3 hitPoint = WorldRayOrigin() + WorldRayDirection() * RayTCurrent();

            // Checkerboard pattern
            float scale = 1.0;
            int checkX = int(floor(hitPoint.x * scale));
            int checkZ = int(floor(hitPoint.z * scale));
            bool isWhite = ((checkX + checkZ) &amp; 1) == 0;
            float3 baseColor = isWhite ? float3(0.9, 0.9, 0.9) : float3(0.2, 0.2, 0.2);

            float3 normal = float3(0.0, 1.0, 0.0);
            float NdotL = max(dot(normal, LightDir), 0.0);

            // Shadow test
            float3 shadowOrigin = hitPoint + normal * 0.001;
            bool inShadow = TraceShadowRay(shadowOrigin, LightDir);

            float shadow = inShadow ? 0.3 : 1.0;
            float3 diffuse = baseColor * LightColor * NdotL * shadow;
            float3 ambient = baseColor * AmbientColor;

            payload.Color = ambient + diffuse;
            payload.T = RayTCurrent();
        }

        [shader(&quot;intersection&quot;)]
        void SphereIntersection()
        {
            uint sphereIndex = PrimitiveIndex();
            Sphere sphere = spheres[sphereIndex];

            float3 origin = ObjectRayOrigin();
            float3 direction = ObjectRayDirection();
            float3 oc = origin - sphere.Center;

            float a = dot(direction, direction);
            float b = dot(oc, direction);
            float c = dot(oc, oc) - sphere.Radius * sphere.Radius;
            float discriminant = b * b - a * c;

            if (discriminant &gt; 0.0)
            {
                float sqrtD = sqrt(discriminant);
                float t1 = (-b - sqrtD) / a;
                float t2 = (-b + sqrtD) / a;

                float t = t1;
                if (t &lt; RayTMin() || t &gt; RayTCurrent())
                {
                    t = t2;
                }

                if (t &gt;= RayTMin() &amp;&amp; t &lt;= RayTCurrent())
                {
                    float3 hitPoint = origin + t * direction;
                    float3 normal = normalize(hitPoint - sphere.Center);

                    SphereAttributes attr;
                    attr.Normal = normal;

                    ReportHit(t, 0, attr);
                }
            }
        }

        [shader(&quot;closesthit&quot;)]
        void SphereClosestHit(inout Payload payload, SphereAttributes attribs)
        {
            uint sphereIndex = PrimitiveIndex();
            Sphere sphere = spheres[sphereIndex];

            float3 hitPoint = WorldRayOrigin() + WorldRayDirection() * RayTCurrent();
            float3 normal = attribs.Normal;
            float NdotL = max(dot(normal, LightDir), 0.0);

            // Shadow test
            float3 shadowOrigin = hitPoint + normal * 0.001;
            bool inShadow = TraceShadowRay(shadowOrigin, LightDir);

            float shadow = inShadow ? 0.3 : 1.0;
            float3 diffuse = sphere.Color * LightColor * NdotL * shadow;
            float3 ambient = sphere.Color * AmbientColor;

            payload.Color = ambient + diffuse;
            payload.T = RayTCurrent();
        }
        &quot;&quot;&quot;;

    private readonly Buffer floorVertexBuffer;
    private readonly Buffer floorIndexBuffer;
    private readonly Buffer sphereBuffer;
    private readonly Buffer aabbBuffer;
    private readonly BottomLevelAccelerationStructure floorBlas;
    private readonly BottomLevelAccelerationStructure sphereBlas;
    private readonly TopLevelAccelerationStructure tlas;
    private readonly ResourceLayout resourceLayout;
    private readonly RayTracingPipeline pipeline;
    private Texture? outputTexture;
    private ResourceSet? resourceSet;

    public RayTracingRenderer()
    {
        if (!App.Context.Capabilities.RayTracingSupported)
        {
            throw new NotSupportedException(&quot;Ray tracing is not supported on this device.&quot;);
        }

        Vector3[] floorVertices =
        [
            new(-5.0f, 0.0f, -5.0f),
            new( 5.0f, 0.0f, -5.0f),
            new( 5.0f, 0.0f,  5.0f),
            new(-5.0f, 0.0f,  5.0f)
        ];
        uint[] floorIndices = [0, 1, 2, 0, 2, 3];

        floorVertexBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Vector3) * floorVertices.Length),
            StrideInBytes = (uint)sizeof(Vector3),
            Flags = BufferUsageFlags.Vertex | BufferUsageFlags.AccelerationStructure
        });
        floorVertexBuffer.Upload(floorVertices, 0);

        floorIndexBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(uint) * floorIndices.Length),
            StrideInBytes = sizeof(uint),
            Flags = BufferUsageFlags.Index | BufferUsageFlags.AccelerationStructure
        });
        floorIndexBuffer.Upload(floorIndices, 0);

        Sphere[] sphereData =
        [
            new() { Center = new(-1.5f, 1.0f, 0.0f), Radius = 1.0f, Color = new(0.8f, 0.2f, 0.2f) },
            new() { Center = new( 1.5f, 1.0f, 0.0f), Radius = 1.0f, Color = new(0.2f, 0.4f, 0.8f) }
        ];

        sphereBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Sphere) * sphereData.Length),
            StrideInBytes = (uint)sizeof(Sphere),
            Flags = BufferUsageFlags.ShaderResource
        });
        sphereBuffer.Upload(sphereData, 0);

        Vector3[] aabbData = new Vector3[sphereData.Length * 2];
        for (int i = 0; i &lt; sphereData.Length; i++)
        {
            aabbData[i * 2] = sphereData[i].Center - new Vector3(sphereData[i].Radius);
            aabbData[(i * 2) + 1] = sphereData[i].Center + new Vector3(sphereData[i].Radius);
        }

        aabbBuffer = App.Context.CreateBuffer(new()
        {
            SizeInBytes = (uint)(sizeof(Vector3) * aabbData.Length),
            StrideInBytes = (uint)(sizeof(Vector3) * 2),
            Flags = BufferUsageFlags.ShaderResource | BufferUsageFlags.AccelerationStructure
        });
        aabbBuffer.Upload(aabbData, 0);

        CommandBuffer buildCmd = App.Context.Graphics.CommandBuffer();

        floorBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
        {
            Geometries =
            [
                new()
                {
                    Type = RayTracingGeometryType.Triangles,
                    Triangles = new()
                    {
                        VertexBuffer = floorVertexBuffer,
                        VertexFormat = PixelFormat.R32G32B32Float,
                        VertexCount = (uint)floorVertices.Length,
                        VertexStrideInBytes = (uint)sizeof(Vector3),
                        IndexBuffer = floorIndexBuffer,
                        IndexFormat = IndexFormat.UInt32,
                        IndexCount = (uint)floorIndices.Length,
                        Transform = Matrix4x4.Identity
                    },
                    Flags = RayTracingGeometryFlags.Opaque
                }
            ],
            Flags = AccelerationStructureBuildFlags.PreferFastTrace
        });

        sphereBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
        {
            Geometries =
            [
                new()
                {
                    Type = RayTracingGeometryType.AABBs,
                    AABBs = new()
                    {
                        Buffer = aabbBuffer,
                        Count = (uint)sphereData.Length,
                        StrideInBytes = (uint)(sizeof(Vector3) * 2)
                    },
                    Flags = RayTracingGeometryFlags.Opaque
                }
            ],
            Flags = AccelerationStructureBuildFlags.PreferFastTrace
        });

        tlas = buildCmd.BuildAccelerationStructure(new TopLevelAccelerationStructureDesc
        {
            Instances =
            [
                new()
                {
                    AccelerationStructure = floorBlas,
                    InstanceID = 0,
                    InstanceMask = 0xFF,
                    InstanceContributionToHitGroupIndex = 0,
                    Transform = Matrix4x4.Identity,
                    Flags = RayTracingInstanceFlags.None
                },
                new()
                {
                    AccelerationStructure = sphereBlas,
                    InstanceID = 1,
                    InstanceMask = 0xFF,
                    InstanceContributionToHitGroupIndex = 1,
                    Transform = Matrix4x4.Identity,
                    Flags = RayTracingInstanceFlags.None
                }
            ],
            Flags = AccelerationStructureBuildFlags.PreferFastTrace
        });

        buildCmd.Submit(waitForCompletion: true);

        resourceLayout = App.Context.CreateResourceLayout(new()
        {
            Bindings = BindingHelper.Bindings
            (
                new()
                {
                    Type = ResourceType.AccelerationStructure,
                    Count = 1,
                    StageFlags = ShaderStageFlags.RayGeneration | ShaderStageFlags.ClosestHit
                },
                new()
                {
                    Type = ResourceType.TextureReadWrite,
                    Count = 1,
                    StageFlags = ShaderStageFlags.RayGeneration
                },
                new()
                {
                    Type = ResourceType.StructuredBuffer,
                    Count = 1,
                    StageFlags = ShaderStageFlags.Intersection | ShaderStageFlags.ClosestHit
                }
            )
        });

        using Shader rayGenShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;RayGen&quot;, ShaderStageFlags.RayGeneration);
        using Shader missShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;Miss&quot;, ShaderStageFlags.Miss);
        using Shader shadowMissShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;ShadowMiss&quot;, ShaderStageFlags.Miss);
        using Shader floorClosestHitShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;FloorClosestHit&quot;, ShaderStageFlags.ClosestHit);
        using Shader sphereIntersectionShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;SphereIntersection&quot;, ShaderStageFlags.Intersection);
        using Shader sphereClosestHitShader = App.Context.LoadShaderFromSource(ShaderSource, &quot;SphereClosestHit&quot;, ShaderStageFlags.ClosestHit);

        pipeline = App.Context.CreateRayTracingPipeline(new()
        {
            RayGeneration = rayGenShader,
            Miss = [missShader, shadowMissShader],
            AnyHit = [],
            Intersection = [sphereIntersectionShader],
            ClosestHit = [floorClosestHitShader, sphereClosestHitShader],
            HitGroups =
            [
                new()
                {
                    Type = HitGroupType.Triangles,
                    Name = &quot;FloorHitGroup&quot;,
                    ClosestHit = &quot;FloorClosestHit&quot;
                },
                new()
                {
                    Type = HitGroupType.Procedural,
                    Name = &quot;SphereHitGroup&quot;,
                    Intersection = &quot;SphereIntersection&quot;,
                    ClosestHit = &quot;SphereClosestHit&quot;
                }
            ],
            ResourceLayouts = [resourceLayout],
            MaxTraceRecursionDepth = 2,
            MaxPayloadSizeInBytes = 16,
            MaxAttributeSizeInBytes = 16
        });
    }

    public void Update(double deltaTime)
    {
    }

    public void Render()
    {
        // Create output texture if needed
        outputTexture ??= App.Context.CreateTexture(new()
        {
            Type = TextureType.Texture2D,
            Format = PixelFormat.R8G8B8A8UNorm,
            Width = App.Width,
            Height = App.Height,
            Depth = 1,
            MipLevels = 1,
            ArrayLayers = 1,
            SampleCount = SampleCount.Count1,
            Flags = TextureUsageFlags.ShaderResource | TextureUsageFlags.UnorderedAccess
        });

        resourceSet ??= App.Context.CreateResourceSet(new()
        {
            Layout = resourceLayout,
            Resources = [tlas, outputTexture, sphereBuffer]
        });

        CommandBuffer commandBuffer = App.Context.Graphics.CommandBuffer();

        commandBuffer.SetPipeline(pipeline);
        commandBuffer.SetResourceSet(resourceSet, 0);
        commandBuffer.DispatchRays(App.Width, App.Height, 1);

        // Copy the ray traced result to the swap chain's color target
        Texture colorTarget = App.SwapChain.FrameBuffer.Desc.ColorAttachments[0].Target;

        commandBuffer.CopyTexture(outputTexture,
                                  default,
                                  default,
                                  colorTarget,
                                  default,
                                  default,
                                  new() { Width = App.Width, Height = App.Height, Depth = 1 });

        commandBuffer.Submit(waitForCompletion: true);
    }

    public void Resize(uint width, uint height)
    {
        resourceSet?.Dispose();
        resourceSet = null;
        outputTexture?.Dispose();
        outputTexture = null;
    }

    public void Dispose()
    {
        resourceSet?.Dispose();
        outputTexture?.Dispose();

        pipeline.Dispose();
        resourceLayout.Dispose();
        tlas.Dispose();
        sphereBlas.Dispose();
        floorBlas.Dispose();
        aabbBuffer.Dispose();
        sphereBuffer.Dispose();
        floorIndexBuffer.Dispose();
        floorVertexBuffer.Dispose();
    }
}

/// &lt;summary&gt;
/// Sphere definition for procedural geometry.
/// &lt;/summary&gt;
[StructLayout(LayoutKind.Sequential)]
file struct Sphere
{
    public Vector3 Center;

    public float Radius;

    public Vector3 Color;

    public float Padding;
}
</code></pre>
<h2 id="running-the-tutorial">Running the Tutorial</h2>
<p>Update your <code>Program.cs</code> to run the <code>RayTracingRenderer</code>:</p>
<pre><code class="lang-csharp">using ZenithTutorials;
using ZenithTutorials.Renderers;

App.Run&lt;RayTracingRenderer&gt;();

App.Cleanup();
</code></pre>
<p>Run the application:</p>
<pre><code class="lang-bash">dotnet run
</code></pre>
<h2 id="result">Result</h2>
<p><img src="../../images/ray-tracing.png" alt="ray-tracing"></p>
<h2 id="code-breakdown">Code Breakdown</h2>
<h3 id="checking-ray-tracing-support">Checking Ray Tracing Support</h3>
<pre><code class="lang-csharp">if (!App.Context.Capabilities.RayTracingSupported)
{
    throw new NotSupportedException(&quot;Ray tracing is not supported on this device.&quot;);
}
</code></pre>
<p>Always check <code>Capabilities.RayTracingSupported</code> before using ray tracing features.</p>
<h3 id="acceleration-structure-setup">Acceleration Structure Setup</h3>
<p>Build a two-level acceleration structure hierarchy:</p>
<pre><code class="lang-csharp">// Floor BLAS (triangle geometry)
floorBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
{
    Geometries =
    [
        new()
        {
            Type = RayTracingGeometryType.Triangles,
            Triangles = new()
            {
                VertexBuffer = floorVertexBuffer,
                VertexFormat = PixelFormat.R32G32B32Float,
                VertexCount = (uint)floorVertices.Length,
                VertexStrideInBytes = (uint)sizeof(Vector3),
                IndexBuffer = floorIndexBuffer,
                IndexFormat = IndexFormat.UInt32,
                IndexCount = (uint)floorIndices.Length,
                Transform = Matrix4x4.Identity
            },
            Flags = RayTracingGeometryFlags.Opaque
        }
    ],
    Flags = AccelerationStructureBuildFlags.PreferFastTrace
});

// Sphere BLAS (procedural AABB geometry)
sphereBlas = buildCmd.BuildAccelerationStructure(new BottomLevelAccelerationStructureDesc
{
    Geometries =
    [
        new()
        {
            Type = RayTracingGeometryType.AABBs,
            AABBs = new()
            {
                Buffer = aabbBuffer,
                Count = (uint)sphereData.Length,
                StrideInBytes = (uint)(sizeof(Vector3) * 2)
            },
            Flags = RayTracingGeometryFlags.Opaque
        }
    ],
    Flags = AccelerationStructureBuildFlags.PreferFastTrace
});
</code></pre>
<p>Combine BLAS into a TLAS with <code>InstanceContributionToHitGroupIndex</code> to select hit groups:</p>
<pre><code class="lang-csharp">tlas = buildCmd.BuildAccelerationStructure(new TopLevelAccelerationStructureDesc
{
    Instances =
    [
        new()
        {
            AccelerationStructure = floorBlas,
            InstanceContributionToHitGroupIndex = 0,  // Uses FloorHitGroup
            Transform = Matrix4x4.Identity,
            ...
        },
        new()
        {
            AccelerationStructure = sphereBlas,
            InstanceContributionToHitGroupIndex = 1,  // Uses SphereHitGroup
            Transform = Matrix4x4.Identity,
            ...
        }
    ],
    Flags = AccelerationStructureBuildFlags.PreferFastTrace
});
</code></pre>
<h3 id="ray-tracing-pipeline">Ray Tracing Pipeline</h3>
<p>Create a pipeline with multiple hit groups:</p>
<pre><code class="lang-csharp">pipeline = App.Context.CreateRayTracingPipeline(new()
{
    RayGeneration = rayGenShader,
    Miss = [missShader, shadowMissShader],
    AnyHit = [],
    Intersection = [sphereIntersectionShader],
    ClosestHit = [floorClosestHitShader, sphereClosestHitShader],
    HitGroups =
    [
        new()
        {
            Type = HitGroupType.Triangles,
            Name = &quot;FloorHitGroup&quot;,
            ClosestHit = &quot;FloorClosestHit&quot;
        },
        new()
        {
            Type = HitGroupType.Procedural,
            Name = &quot;SphereHitGroup&quot;,
            Intersection = &quot;SphereIntersection&quot;,
            ClosestHit = &quot;SphereClosestHit&quot;
        }
    ],
    ResourceLayouts = [resourceLayout],
    MaxTraceRecursionDepth = 2,
    MaxPayloadSizeInBytes = 16,
    MaxAttributeSizeInBytes = 16
});
</code></pre>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RayGeneration</code></td>
<td>Entry point shader</td>
</tr>
<tr>
<td><code>Miss</code></td>
<td>Array of miss shaders (index 0 for primary rays, index 1 for shadow rays)</td>
</tr>
<tr>
<td><code>HitGroups</code></td>
<td>Bundle shaders for each geometry type</td>
</tr>
<tr>
<td><code>MaxTraceRecursionDepth</code></td>
<td>Maximum ray bounce depth (set to 2 for shadow rays)</td>
</tr>
<tr>
<td><code>MaxPayloadSizeInBytes</code></td>
<td>Size of data passed between shaders</td>
</tr>
</tbody>
</table>
<h3 id="custom-intersection-shader">Custom Intersection Shader</h3>
<p>For procedural geometry (AABBs), implement ray-sphere intersection:</p>
<pre><code class="lang-slang">[shader(&quot;intersection&quot;)]
void SphereIntersection()
{
    Sphere sphere = spheres[PrimitiveIndex()];

    float3 origin = ObjectRayOrigin();
    float3 direction = ObjectRayDirection();
    float3 oc = origin - sphere.Center;

    // Solve quadratic equation for ray-sphere intersection
    float a = dot(direction, direction);
    float b = dot(oc, direction);
    float c = dot(oc, oc) - sphere.Radius * sphere.Radius;
    float discriminant = b * b - a * c;

    if (discriminant &gt; 0.0)
    {
        float t = (-b - sqrt(discriminant)) / a;
        if (t &gt;= RayTMin() &amp;&amp; t &lt;= RayTCurrent())
        {
            SphereAttributes attr;
            attr.Normal = normalize(origin + t * direction - sphere.Center);
            ReportHit(t, 0, attr);
        }
    }
}
</code></pre>
<p>The intersection shader:</p>
<ol>
<li>Gets the sphere data using <code>PrimitiveIndex()</code></li>
<li>Computes ray-sphere intersection using the quadratic formula</li>
<li>Reports hit with <code>ReportHit(t, hitKind, attributes)</code> if intersection is valid</li>
</ol>
<h3 id="hard-shadows">Hard Shadows</h3>
<p>Hard shadows test visibility to a point light source. If any geometry blocks the ray, the point is in shadow:</p>
<pre><code class="lang-slang">bool TraceShadowRay(float3 origin, float3 direction)
{
    RayDesc shadowRay;
    shadowRay.Origin = origin;
    shadowRay.Direction = direction;
    shadowRay.TMin = 0.001;
    shadowRay.TMax = 1000.0;

    ShadowPayload shadowPayload;
    shadowPayload.InShadow = true;

    TraceRay(scene,
             RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER,
             0xFF, 0, 0, 1, shadowRay, shadowPayload);

    return shadowPayload.InShadow;
}
</code></pre>
<p>Key optimizations:</p>
<ul>
<li><code>RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH</code>: Stop at first hit (we only need to know if something blocks the light)</li>
<li><code>RAY_FLAG_SKIP_CLOSEST_HIT_SHADER</code>: Skip shading for shadow rays (we don't need material information)</li>
<li>Miss shader index <code>1</code> in <code>TraceRay</code> selects <code>ShadowMiss</code> instead of the primary <code>Miss</code> shader</li>
</ul>
<h3 id="dispatching-rays">Dispatching Rays</h3>
<pre><code class="lang-csharp">commandBuffer.SetPipeline(pipeline);
commandBuffer.SetResourceSet(resourceSet, 0);
commandBuffer.DispatchRays(App.Width, App.Height, 1);
</code></pre>
<p><code>DispatchRays(width, height, depth)</code> launches the ray generation shader for each pixel.</p>
<h3 id="copying-to-the-swap-chain">Copying to the Swap Chain</h3>
<pre><code class="lang-csharp">Texture colorTarget = App.SwapChain.FrameBuffer.Desc.ColorAttachments[0].Target;

commandBuffer.CopyTexture(outputTexture,
                          default,
                          default,
                          colorTarget,
                          default,
                          default,
                          new() { Width = App.Width, Height = App.Height, Depth = 1 });
</code></pre>
<p>Instead of using a full-screen quad with a graphics pipeline, we directly copy the ray traced result to the swap chain's color target. This is simpler and more efficient when you just need to display a texture without additional processing.</p>
<h2 id="next-steps">Next Steps</h2>
<ul>
<li><a href="mesh-shading.html">Mesh Shading</a> - Process geometry in meshlets using the modern mesh shading pipeline</li>
</ul>
<h2 id="source-code">Source Code</h2>
<div class="TIP">
<h5>Tip</h5>
<p>View the complete source code on GitHub: <a href="https://github.com/qian-o/ZenithTutorials/blob/master/ZenithTutorials/Renderers/RayTracingRenderer.cs">RayTracingRenderer.cs</a></p>
</div>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/qian-o/Zenith.NET/blob/master/documents/tutorials/advanced/ray-tracing.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>
